<h1>Макросы и квазицитаты в Scala 2.11.0</h1>

Не так давно состоялся <a href="http://habrahabr.ru/post/220469/">релиз Scala 2.11.0</a>. Одним из примечательных нововведений этой версии являются квазицитаты - удобный механизм для описания синтаксических деревьев Scala с помощью разбираемых во время компиляции строк; очевидно, что в первую очередь этот механизм предназначен для использования совместно с макросами.

Удивительно, но на хабре пока тему макросов в Scala рассматривают не слишком-то активно; <a href="http://habrahabr.ru/post/176285/">последний пост</a>
с серьёзным рассмотрением макросов был аж целый год назад.

В данном посте будет подробно рассмотрено написание простого макроса, предназначенного для генерации кода десериализации JSON в иерархию классов.
<habracut>
<h4>Постановка задачи</h4>
Существует замечательная библиотека для работы с JSON для Scala - <a href="https://github.com/spray/spray-json">spray.json</a>.

Обычно для того, чтобы десериализовать какой-то JSON-объект с помощью этой библиотеки, достаточно пары импортов:

<source lang="scala">
// Объявление класса, который будем десериализовывать:
case class MyClass(field: String)

// Импорт объектов spray.json:
import spray.json._
import DefaultJsonProtocol._
implicit val myClassFormat = jsonFormat1(MyClass)

val json = """{ "field\": "value" }"""
val obj = json.parseJson.convertTo[MyClass] // ok
</source>
Достаточно просто, не правда ли? А если мы хотим десериализовать иерархию классов целиком? Приведу пример иерархии, которую мы будем рассматривать в дальнейшем:

<source lang="scala">
abstract sealed class Message()

case class SimpleMessage() extends Message
case class FieldMessage(field: String) extends Message
case class NestedMessage(nested: Message) extends Message
case class MultiMessage(field: Int, nested: Message) extends Message
</source>
Как видно, несколько десериализуемых классов с разным количеством аргументов различных типов наследуются от абстрактного родителя. Вполне естественное желание при десериализации таких сущностей - это добавить поле <code>type</code> в JSON-объект, а при десериализации диспетчеризоваться по этому полю. Идея может быть выражена следующим псевдокодом:

<source lang="scala">
json.type match {
  case "SimpleMessage" =&gt; SimpleMessage()
  case "FieldMessage" =&gt; FieldMessage(json.field)
  // ...
}
</source>
Библиотека spray.json предоставляет возможность определить конвертацию JSON в любые типы по определяемым пользователем правилам посредством расширения форматтера <code>RootJsonFormat</code>. Звучит совсем как то, что нам нужно. Ядро нашего форматтера должно выглядеть следующим образом:

<source lang="scala">
val typeName = ...
typeName match {
  case "FieldMessage" =&gt; map.getFields("field") match {
    case Seq(field) =&gt; new FieldMessage(field.convertTo[String])
  }
  case "NestedMessage" =&gt; map.getFields("nested") match {
    case Seq(nested) =&gt; new NestedMessage(nested.convertTo[Message])
  }
  case "MultiMessage" =&gt; map.getFields("field", "nested") match {
    case Seq(field, nested) =&gt; new MultiMessage(field.convertTo[Int], nested.convertTo[Message])
  }
  case "SimpleMessage" =&gt; map.getFields() match {
    case Seq() =&gt; new SimpleMessage()
  }
}
</source>
Выглядит этот код немного... шаблонным. Это же отличная задача для макроса! Оставшаяся часть статьи посвящена разработке макроса, который сможет сгенерировать такой код, имея в качестве отправной точки лишь тип <code>Message</code>.

<h5>Организация проекта</h5>
Первое препятствие, с которым программист сталкивается при разработке макросов, заключается в том, что SBT не хочет компилировать одновременно и макрос, и использующий его код. Данная проблема рассмотрена в документации SBT и я рекомендую описанное ниже решение.

Нужно разделить код макросов и основной код приложения на два проекта, на которые следует сослаться в главном файле <code>project/Build.sbt</code>. В сопровождающем статью коде уже сделаны эти приготовления, вот ссылки на результирующие файлы:

<ul>
  <li><a href="https://github.com/ForNeVeR/macrojson/blob/master/project/Build.scala">главный сборочный файл <code>project/Build.sbt</code></a>;</li>
  <li><a href="https://github.com/ForNeVeR/macrojson/blob/master/macro/build.sbt">проект для макросов: <code>macro/build.sbt</code></a>;</li>
  <li><a href="https://github.com/ForNeVeR/macrojson/blob/master/main/build.sbt">основной проект: <code>main/build.sbt</code></a>.</li>
</ul>
Ещё одна тонкость заключается в том, что если вы хотите, чтобы макрос работал с иерархией классов - на момент раскрытия макроса эта иерархия должна быть известна. Это вызывает некоторые проблемы, т.к. последовательность обработки файлов компилятором не всегда очевидна. Решение этого вопроса - либо располагать классы, с которыми должен работать макрос, в одном проекте с макросом (при этом раскрытие макроса по-прежнему должно быть в другом проекте), или просто разместить нужные классы в том же файле, в котором производится раскрытие макроса.

При отладке макросов очень помогает параметр компилятора <code>-Ymacro-debug-lite</code>, который позволяет вывести в консоль результаты разворачивания всех макросов в проекте (эти результаты очень похожи на код Scala, и зачастую могут быть без изменений скомпилированы вручную при передаче компилятору, что может помочь в отладке нетривиальных случаев).

<h4>Макросы</h4>
Макросы в Scala работают почти так же, как reflection. Обратите внимание, Scala reflection API значительно отличается от Java reflection, поскольку не все концепции Scala известны стандартной библиотеке Java.

Механизм макросов в Scala предоставляет возможность создания участков кода во время компиляции. Это делается с помощью строго типизированного API, который генерирует синтаксические деревья, соответствующие коду, который вы хотите создать. Макросы Scala значительно отличаются от всем привычных макросов языка C, так что путать их не стоит.

В основе макросов Scala лежит класс <code>Context</code>. Экземпляр этого класса всегда передаётся макросу при раскрытии. Затем можно из него импортировать внутренности объекта <code>Universe</code> и использовать их точно так же, как в runtime reflection - запрашивать оттуда дескрипторы типов, методов, свойств и т.п. Этот же контекст позволяет создавать синтаксические деревья при помощи классов наподобие <code>Literal</code>, <code>Constant</code>, <code>List</code> и др.

По сути макрос - это функция, которая принимает и возвращает синтаксические деревья. Напишем шаблон нашего макроса:

<source lang="scala">
import scala.language.experimental.macros
import scala.reflect.macros.blackbox.Context
import spray.json._

object Parsers {

  def impl[T: c.WeakTypeTag](c: Context)(typeName: c.Expr[String], map: c.Expr[JsObject]): c.Expr[T] = {
    import c.universe._

    val cls = weakTypeOf[T].typeSymbol.asClass

    val tree = ??? // построение синтаксического дерева будет рассмотрено дальше
    c.Expr[T](tree)
  }

  def parseMessage[T](typeName: String, map: JsObject): T = macro Parsers.impl[T]

}
</source>
Макрос <code>parseMessage[T]</code> принимает тип <code>T</code>, который является базовым для иерархии десериализуемых классов, и синтаксическое дерево для получения типа десериализуемого объекта <code>map</code>, а возвращает синтаксическое дерево для получения десериализованного объекта, приведённого к базовому типу <code>T</code>.

Аргумент типа <code>T</code> описан специальным образом: указано, что компилятор должен приложить к нему неявно сгенерированный объект типа <code>c.WeakTypeTag</code>. Вообще говоря, неявный аргумент <code>TypeTag</code> используется в Scala для того, чтобы работать с типами-аргументами генериков, обычно недоступными во время выполнения из-за <a href="http://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">type erasure</a>. Для аргументов макросов компилятор требует использовать не просто <code>TypeTag</code>, а <code>WeakTypeTag</code>, что, насколько я понимаю, связано с особенностями работы компилятора (у него нет "полноценного" <code>TypeTag</code> для типа, который может быть ещё не полностью сгенерирован во время раскрытия макроса). Тип, ассоциированный с <code>TypeTag</code>, можно получить при помощи метода <code>typeOf[T]</code> объекта <code>Universe</code>; соответственно, для <code>WeakTypeTag</code> существует метод <code>weakTypeOf[T]</code>.

Одним из недостатков макросов является неочевидность описания синтаксических деревьев. Например, фрагмент кода <code>2 + 2</code> при генерации должен выглядеть как <code>Apply(Select(Literal(Constant(2)), TermName("$plus")), List(Literal(Constant(2))))</code>; ещё более серьёзные случаи начинаются, когда нам нужно представить более крупные куски кода с подстановкой шаблонов. Естественно, такая сложность нам не нравится и мы будем её преодолевать.

<h4>Квазицитаты</h4>
Вышеупомянутый недостаток макросов начиная с версии Scala 2.11.0 может быть легко решён с помощью квазицитат. Например, вышеупомянутая конструкция, описывающая выражение <code>2 + 2</code>, в виде квазицитаты будет выглядеть просто как <code>q"2 + 2"</code>, что очень удобно. В целом квазицитаты в Scala - это набор строковых интерполяторов, которые расположены в объекте <code>Universe</code>. После импортирования этих интерполяторов в текущей область видимости появляется возможность использовать ряд символов перед строковой константой, которые определяют её обработку компилятором. В частности, при реализации рассматриваемой задачи нам пригодятся интерполяторы <code>pq</code> для паттернов, <code>cq</code> для веток выражения <code>match</code>, а также <code>q</code> для законченных выражений языка.

Как и для других строковых интерполяторов языка Scala, из квазицитат можно ссылаться на переменные окружающей их области видимости. Например, для генерации выражения <code>2 + 2</code> можно воспользоваться следующим кодом:

<source lang="scala">
val a = 2
q"$a + $a"
</source>
Для переменных разных типов интерполяция может происходить по-разному. Например, переменные строкового типа в генерируемых деревьях становятся <i>строковыми константами</i>. Для того, чтобы сослаться на переменную по имени, нужно создать объект <code>TermName</code>.

Как видно из примера генерируемого кода, приведённого в начале статьи, нам нужно уметь генерировать следующие элементы:
<ul>
  <li><code>match</code> по переменной <code>typeName</code> с ветками <code>case</code>, соответствующими каждому типу иерархии;</li>
  <li>в каждой ветке - передача списка названий аргументов конструктора соответствующего класса в метод <code>map.getFields</code>;</li>
  <li>там же - деконструкция полученной последовательности (с помощью того же выражения <code>match</code>) на переменные и передача этих переменных в конструктор типа.</li>
</ul>
В первую очередь рассмотрим генерацию общего дерева всего выражения <code>match</code>. Для этого придётся использовать интерполяцию переменных в контексте квазицитаты:

<source lang="scala">
val clauses: Set[Tree] = ??? // см. ниже
val tree = q"$typeName match { case ..$clauses }"
</source>
В данном участке кода используется особый вид интерполяции. Выражение <code>case ..$clauses</code> внутри блока <code>match</code> будет раскрыто как список ветвей <code>case</code>. Как мы помним, каждая ветвь должна выглядеть следующим образом:

<source lang="scala">
case "FieldMessage" =&gt; map.getFields("field") match {
  case Seq(field) =&gt; new FieldMessage(field.convertTo[String])
}
</source>
В виде квазицитаты такая ветка может быть записана следующим образом:

<source lang="scala">
val tpe: Type // обрабатываемый наследник
val constructorParameters: List[Symbol] // список параметров конструктора

val parameterNames = constructorParameters.map(_.name)
val parameterNameStrings = parameterNames.map(_.toString)

// Паттерны для дальнейшего матчинга создаются с помощью интерпорятора pq:
val parameterBindings = parameterNames.map(name =&gt; pq"$name")

// Это будут выражения, результаты которых передаются в конструктор:
val args = constructorParameters.map { param =&gt;
  val parameterName = TermName(param.name.toString)
  val parameterType = param.typeSignature
  q"$parameterName.convertTo[$parameterType]"
}

// Генерируем окончательный вид ветки case:
val typeName = tpe.typeSymbol
val typeNameString = typeName.name.toString
cq"""$typeNameString =&gt;
       $map.getFields(..$parameterNameStrings) match {
         case Seq(..$parameterBindings) =&gt; new $typeName(..$args)
       }"""
</source>
В данном фрагменте кода используется несколько квазицитат: выражение <code>pq"$name"</code> создаёт набор паттернов, которые в дальнейшем подставляются в выражение <code>Seq(...)</code>. Каждое из этих выражений имеет тип <code>JsValue</code>, который нужно преобразовать к соответствующему типу перед передачей в конструктор; для этого используется квазицитата, генерирующая вызов метода <code>convertTo</code>. Обратите внимание, этот метод может рекурсивно вызвать наш форматтер при необходимости (то есть можно вкладывать объекты типа <code>Message</code> друг в друга.

Наконец, результирующее синтаксическое дерево, состоящее из выражения <code>match</code> со сгенерированными нами ветками <code>case</code> может быть построено также с использованием интерполяции:

<source lang="scala">
val tree = q"$typeName match { case ..$clauses }"
</source>
Это дерево будет встроено компилятором по месту применения макроса.

<h4>Выводы</h4>
В течение всего времени развития технологий, метапрограммирование становится всё более важным элементом языков программирования, всё чаще его применяют в повседневном коде для реализации различных концепций. Макросы Scala являются актуальным инструментом, который может избавить нас от различной рутинной работы, которую в мире JVM ранее было принято реализовывать через рефлексию или кодогенерацию.

Безусловно, макросы - это мощный инструмент, которым следует пользоваться осторожно: при неправильном использовании достаточно просто отстрелить себе ногу и упасть в пропасть неподдерживаемого кода. Однако всегда стоит стараться автоматизировать рутинную деятельность, и если макросы смогут стать для нас подспорьем в этой задаче - они будут использоваться и будут приносить пользу сообществу.

<h4>Использованные материалы</h4>
<ol>
  <li><a href="http://docs.scala-lang.org/overviews/macros/overview.html">Обзор макросов из документации Scala</a>.</li>
  <li><a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html">Обзор квазицитат из документации Scala</a>.</li>
  <li><a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">Обзор строковой интерполяции из документации Scala</a>.</li>
  <li><a href="http://www.scala-sbt.org/0.13.2/docs/Detailed-Topics/Macro-Projects.html">Руководство по макропроектам для SBT</a>.</li>
  <li><a href="https://github.com/ForNeVeR/macrojson">Исходный код и тесты к статье</a>.</li>
</ol>
